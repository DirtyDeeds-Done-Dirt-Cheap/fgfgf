<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Напоминания с точным временем</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 40px;
      max-width: 600px;
    }
    h1 {
      margin-bottom: 20px;
    }
    #reminderText {
      width: 200px;
      padding: 8px;
      font-size: 14px;
    }
    #reminderDate, #reminderTime {
      padding: 8px;
      font-size: 14px;
    }
    #addReminder {
      padding: 8px 16px;
      font-size: 14px;
      margin-left: 10px;
      cursor: pointer;
    }
    ul {
      list-style-type: none;
      padding-left: 0;
    }
    li {
      background: #f5f5f5;
      margin: 8px 0;
      padding: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    button.delete {
      background-color: #ff5555;
      border: none;
      padding: 6px 10px;
      color: white;
      cursor: pointer;
    }

    /* Стили для полноэкранного оверлея */
    #overlay {
      position: fixed;
      top: 0; 
      left: 0; 
      width: 100vw; 
      height: 100vh; 
      background: rgba(0, 0, 0, 0.8);
      display: none; 
      align-items: center; 
      justify-content: center;
      color: #fff;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
      z-index: 9999; /* поверх всего */
    }
    #overlayContent {
      max-width: 800px;
      background: rgba(0,0,0,0.2);
      padding: 20px;
      border-radius: 6px;
    }
    #overlayTitle {
      font-size: 24px;
      margin-bottom: 20px;
    }
    #overlayDateTime {
      font-size: 18px;
    }
    #closeOverlay {
      background-color: #ff5555;
      border: none;
      padding: 10px 20px;
      color: white;
      cursor: pointer;
      font-size: 16px;
      margin-top: 20px;
    }
  </style>
</head>
<body>

  <h1>Мои напоминания (с точным запуском)</h1>
  
  <!-- Форма добавления нового напоминания -->
  <div>
    <input type="text" id="reminderText" placeholder="Текст напоминания" />
    <input type="date" id="reminderDate" />
    <input type="time" id="reminderTime" />
    <button id="addReminder">Добавить</button>
  </div>

  <!-- Список напоминаний -->
  <ul id="reminderList"></ul>

  <!-- Оверлей для вывода напоминаний во весь экран -->
  <div id="overlay">
    <div id="overlayContent">
      <div id="overlayTitle"></div>
      <div id="overlayDateTime"></div>
      <button id="closeOverlay">Закрыть</button>
    </div>
  </div>

  <script>
    // === ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ===
    // Храним список напоминаний в localStorage
    let reminders = JSON.parse(localStorage.getItem('reminders')) || [];

    // Массив таймеров (setTimeout), чтобы можно было их при необходимости отменять
    let reminderTimeouts = [];

    const reminderTextInput = document.getElementById('reminderText');
    const reminderDateInput = document.getElementById('reminderDate');
    const reminderTimeInput = document.getElementById('reminderTime');
    const addReminderBtn    = document.getElementById('addReminder');
    const reminderList      = document.getElementById('reminderList');

    // Оверлей (для вывода "на весь экран")
    const overlay           = document.getElementById('overlay');
    const overlayTitle      = document.getElementById('overlayTitle');
    const overlayDateTime   = document.getElementById('overlayDateTime');
    const closeOverlayBtn   = document.getElementById('closeOverlay');

    // Очередь срабатывающих напоминаний, если в один момент &laquo;выстрелили&raquo; несколько
    let triggeredQueue      = [];
    // Флаг: показывается ли сейчас оверлей
    let isOverlayVisible    = false;

    // === ФУНКЦИИ ===

    // Сохранение массива напоминаний в localStorage
    function saveRemindersToLocalStorage() {
      localStorage.setItem('reminders', JSON.stringify(reminders));
    }

    // Рендер (перерисовка) списка на странице
    function renderReminders() {
      reminderList.innerHTML = '';

      reminders.forEach((reminder, index) => {
        const li = document.createElement('li');
        
        let displayText = reminder.text;
        if (reminder.date || reminder.time) {
          displayText += ' (';
          if (reminder.date) {
            displayText += `дата: ${reminder.date}`;
          }
          if (reminder.time) {
            if (reminder.date) displayText += ', ';
            displayText += `время: ${reminder.time}`;
          }
          displayText += ')';
        }

        const textSpan = document.createElement('span');
        textSpan.textContent = displayText;

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Удалить';
        deleteBtn.className = 'delete';
        deleteBtn.addEventListener('click', () => {
          // Удаляем из массива
          reminders.splice(index, 1);
          saveRemindersToLocalStorage();

          // Перезапускаем таймеры
          resetAllTimers();
          renderReminders();
        });

        li.appendChild(textSpan);
        li.appendChild(deleteBtn);
        reminderList.appendChild(li);
      });
    }

    // Показ оверлея (во весь экран)
    function showOverlay(reminder) {
      isOverlayVisible = true;
      overlayTitle.textContent = reminder.text || '';
      
      let dtText = '';
      if (reminder.date) dtText += `Дата: ${reminder.date}`;
      if (reminder.time) {
        dtText += (dtText ? ' / ' : '') + `Время: ${reminder.time}`;
      }
      overlayDateTime.textContent = dtText;

      overlay.style.display = 'flex';

      // Попытка перейти в fullscreen (может быть заблокировано браузером)
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(err => {
          console.warn('Fullscreen API отклонил запрос:', err);
        });
      }
    }

    // Закрытие оверлея
    function hideOverlay() {
      overlay.style.display = 'none';
      isOverlayVisible = false;

      if (document.exitFullscreen) {
        document.exitFullscreen().catch(err => {
          console.warn('Не удалось выйти из fullscreen:', err);
        });
      }

      // Проверяем, не остались ли ещё &laquo;на очереди&raquo; напоминания
      if (triggeredQueue.length > 0) {
        const next = triggeredQueue.shift();
        showOverlay(next);
      }
    }

    closeOverlayBtn.addEventListener('click', hideOverlay);

    // Добавление нового напоминания
    addReminderBtn.addEventListener('click', () => {
      const textValue = reminderTextInput.value.trim();
      const dateValue = reminderDateInput.value;   // "YYYY-MM-DD"
      const timeValue = reminderTimeInput.value;   // "HH:MM"

      if (!textValue) return; // Нет текста — не добавляем

      // Если у пользователя нет даты/времени — всё равно можно сохранить, но "автосработка" не произойдёт
      reminders.push({
        text: textValue,
        date: dateValue,
        time: timeValue
      });

      saveRemindersToLocalStorage();

      // Перезадаём все таймеры заново (чтобы учесть новое напоминание)
      resetAllTimers();

      // Перерисовываем список
      renderReminders();

      // Сброс полей ввода
      reminderTextInput.value = '';
      reminderDateInput.value = '';
      reminderTimeInput.value = '';
    });

    // Отмена всех таймеров (clearTimeout)
    function cancelAllTimers() {
      reminderTimeouts.forEach(t => clearTimeout(t));
      reminderTimeouts = [];
    }

    // Устанавливаем новый таймер для *каждого* напоминания (если время в будущем)
    function resetAllTimers() {
      // Сначала отменяем любые старые таймеры
      cancelAllTimers();

      const now = new Date();

      reminders.forEach((reminder, index) => {
        if (!reminder.date && !reminder.time) {
          // Если дата/время не указаны — автоматически не сработает
          return;
        }

        // Формируем объект Date на основании date/time
        let datePart = reminder.date ? reminder.date : new Date().toISOString().slice(0, 10); 
        let timePart = reminder.time ? reminder.time : '00:00';
        // Собираем строку в формате YYYY-MM-DDTHH:mm
        let dateTimeString = datePart + 'T' + timePart;
        let reminderDateObj = new Date(dateTimeString);

        // Разница между нужным моментом и сейчас
        let diff = reminderDateObj - now;  // в миллисекундах

        // Ставим таймер только если diff > 0, то есть будущее время
        if (diff > 0) {
          // Создаём таймер
          let timerId = setTimeout(() => {
            // Когда таймер &laquo;сработал&raquo;, мы:
            // 1) Удаляем напоминание из массива (чтобы не срабатывало повторно)
            // 2) Сохраняем в localStorage
            // 3) Пытаемся показать оверлей

            // Защита от случая, если напоминание уже удалили вручную
            const idx = reminders.indexOf(reminder);
            if (idx !== -1) {
              reminders.splice(idx, 1);
              saveRemindersToLocalStorage();
              renderReminders();

              // Если оверлей не показан — показываем
              // Если уже кто-то показывается — добавляем в очередь
              if (!isOverlayVisible) {
                showOverlay(reminder);
              } else {
                triggeredQueue.push(reminder);
              }
            }
          }, diff);

          reminderTimeouts.push(timerId);
        }
      });
    }

    // При загрузке: отрисовать существующие напоминания и установить таймеры
    renderReminders();
    resetAllTimers();
  </script>

</body>
</html>
